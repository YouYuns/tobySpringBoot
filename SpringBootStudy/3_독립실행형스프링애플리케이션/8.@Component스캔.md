### ✅ @Component 스캔

1. 아래 코드는 클래스 정보를 Register Bean메서드에 넘겨주거나 팩토리 메서드를 만들어서 직접 빈 인스턴스를 생성하는 방법이다.
2. 하지만 이것보다 더 간결하게 빈을 등록해보자
```java

import com.example.tobyspringboot.HelloController;
import com.example.tobyspringboot.HelloService;
import com.example.tobyspringboot.SimpleHelloService;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.support.GenericApplicationContext;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.web.context.support.GenericWebApplicationContext;
import org.springframework.web.servlet.DispatcherServlet;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Configuration
public class TobySpringBootApplication {

    //팩토리 메서드 만들기 -> HelloController타입의 빈오브젝트가 만들어진다 -> 스프링 컨테이너가 사용하겠다
    //내가 자바코드로 HelloController를 만들건데 그떄 필요한 의존 오브젝트를 파라미터로 넘겨줘하면된다.
    //이정보가 스프링 컨테이너에게 정보를 전달하기위해서 애노테이션을 전달해준다. -> @Bean
    @Bean
    public HelloController helloController(HelloService helloService) {
        return new HelloController(helloService);
    }

    //팩토리 메서드 만들기 -> HelloService타입의 빈오브젝트가 만들어진다 -> 스프링 컨테이너가 사용하겠다
    @Bean
    public HelloService helloService() {
        return new SimpleHelloService();
    }

    public static void main(String[] args) {
        //스프링 컨테이너를 만드는 작업
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext() {

            @Override
            protected void onRefresh() {
                super.onRefresh();
                //서블릿을 등록하는 작업
                WebServer webServer = serverFactory.getWebServer((ServletContextInitializer)
                        servletContext -> {
                            // 저 HelloController라는 것은 매 요청마다 새로운 인스턴스를 만들 필요가 없다 계속 재사용해도된다.
                            servletContext.addServlet("dispatcherServlet",
                                    new DispatcherServlet(this)
                            ).addMapping("/*");
                        });
                webServer.start();
            }
        };
//        applicationContext.registerBean(HelloController.class);
//        applicationContext.registerBean(SimpleHelloService.class);
        applicationContext.register(com.example.tobyspringboot.TobySpringBootApplication.class);
        applicationContext.refresh();

        //서블릿 컨테이너를 코드로 실행
        ServletWebServerFactory serverFactory = new TomcatServletWebServerFactory();
    }
}
``` 

3. 명시적으로 빈을 등록하는걸 코드로 작성하거나 설정 파일을 만드는 대신에 클래스에 애노테이션을 이용해서 레이블을 붙여주는 것이다.
4. 그러면 스프링 컨테이너에 있는 컴포넌트 스캐너가 있는데 @Component라는 애노테이션이 붙은 모든 걸 찾아서 빈으로 등록을 해준다.

```java


import org.springframework.context.annotation.ComponentScan;

@Configuration
@ComponentScan
public class TobySpringBootApplication {


    public static void main(String[] args) {
        //스프링 컨테이너를 만드는 작업
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext() {

            @Override
            protected void onRefresh() {
                super.onRefresh();
                //서블릿을 등록하는 작업
                WebServer webServer = serverFactory.getWebServer((ServletContextInitializer)
                        servletContext -> {
                            // 저 HelloController라는 것은 매 요청마다 새로운 인스턴스를 만들 필요가 없다 계속 재사용해도된다.
                            servletContext.addServlet("dispatcherServlet",
                                    new DispatcherServlet(this)
                            ).addMapping("/*");
                        });
                webServer.start();
            }
        };
//        applicationContext.registerBean(HelloController.class);
//        applicationContext.registerBean(SimpleHelloService.class);
        applicationContext.register(com.example.tobyspringboot.TobySpringBootApplication.class);
        applicationContext.refresh();

        //서블릿 컨테이너를 코드로 실행
        ServletWebServerFactory serverFactory = new TomcatServletWebServerFactory();
    }
}
```

```java
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.RestController;

@RestController
@Component
public class HelloController {


    private final HelloService helloService;

    public HelloController(HelloService helloService) {
        this.helloService = helloService;
    }

    @GetMapping("/hello")
    public String hello(String name) {
        return helloService.sayHello(Objects.requireNonNull(name));
    }
}
```

```java
import org.springframework.stereotype.Component;

@Component
public interface HelloService {
    String sayHello(String name);
}

```
### 📌 ComponentScan 
    - 이 클래스가 있는 패키지부터 시작해서 하위 패키지까지 찾아서 컴포넌트 애노테이션을 모두 찾아서 빈으로 등록한다.
    - 빈을 등록할때 필요하다면 의존 오브젝트를 찾아내고 생성자를 만들때 파라미터를 넘겨주기도 한다.
    - 장점 : 새로운 빈을 만들어서 추가할 때 매번 구성정보를 다시 등록해 줄 필요가 없이 내가 작성하는 클래스가 빈으로 등록되어서 사용되어 질거라면 간단하게 @Component 애노테이션만 붙여주면된다.
    - 단점 : @Component붙은 클래스가 많아지면 어떤게 정확히 등록되어있는지 찾아보기가 힘들다 하지만 장점이 훨씬 크고 모듈을 잘정리해서 만들면 단점은 작다.
### 📌 Component
    - 직접 빈 클래스에 붙여도되지만 이 애노테이션을 메타애노테이션으로 가지고있는 애노테이션으로 붙여도 컴포넌트라는 붙인것과 동일한 효과다.
### 📌 Meta Annotation
    - 애노테이션 위에 붙은 애노테이션

5. 애노테이션을 직접 만들어보자 
    - 애노테이션을 처음 생성하면 꼭 붙여줘야하는게 있다.
      - @Retention() : 이 애노테이션이 어디까지 살아있을것인가 어디까지 유지될것인가 일단 RUNTIME으로 지정
```java
@Retention()
public @interface MyComponent {
}

```